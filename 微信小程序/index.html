<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta name="description" content="微信小程序 - https://aituyaa.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">
    <meta name="author" content="Jack - https://aituyaa.com/">
    
    <meta name="msvalidate.01" content="B46311949B856F2A7015F366FB3CE878" />
    <title>微信小程序</title>
    
    <base target="_blank">
    <link rel="icon" type="image/png" href="/favicon.ico">
    
    
    
    
    
    <link rel="stylesheet" href="https://aituyaa.com/style.min.7a1211384e00d894dc501a9708ae5fb349825c010d5348b62a8727d135f41615.css">
    
    <script>const DARK =  false ;</script>
    
    <script type="text/javascript" src="/main.js" defer></script>
    
</head>
<body class="active-animate cool">
        
        <div class="cool-before" style="background: url('/imgs/bg/color.jpg') left top/100% no-repeat fixed;"></div>
        <div id="header" class=""><div class="container-header">

    
    
    
    <div class="right">
        
        <h1 class="title">微信小程序</h1>
    
        
        
            <div id="toc">📜</div>
        
    </div>
</div>
</div>
        <div id="content">










<div class="container-main container-page ">

    

    
    
    
    <div class="rel">
        
        
        
        
        
        
        
        <div class="curtag-desc">
            <a href="https://aituyaa.com/tags/_misc/"><img src="/imgs/icons/tag.svg" width="16" /> 相关文章：_Misc <sup>18</sup></a>
        </div>

        <div class="curtag-post">
            
            
            
                <div class="curtag-post-item ">
                    <a href="https://aituyaa.com/cdn-%E5%9B%9E%E6%BA%90%E6%B5%81%E5%87%BA%E6%B5%81%E9%87%8F/">CDN 回源流出流量</a>
                </div>
                
                
            
            
                <div class="curtag-post-item ">
                    <a href="https://aituyaa.com/cpu-%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%B6%E9%80%A0%E5%87%BA%E6%9D%A5%E7%9A%84/">CPU 是如何制造出来的</a>
                </div>
                
                
            
            
                <div class="curtag-post-item ">
                    <a href="https://aituyaa.com/cpu-%E7%BC%93%E5%AD%98%E6%98%AF%E4%BB%80%E4%B9%88/">CPU 缓存是什么</a>
                </div>
                
                
            
            
                <div class="curtag-post-item ">
                    <a href="https://aituyaa.com/windows-%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/">Windows 那些事儿</a>
                </div>
                
                
            
            
                <div class="curtag-post-item ">
                    <a href="https://aituyaa.com/%E4%BA%91%E7%9B%98%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/">云盘那些事儿</a>
                </div>
                
                
            
            
                <div class="curtag-post-item ">
                    <a href="https://aituyaa.com/%E5%85%B3%E4%BA%8E%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%E7%B3%BB%E5%88%97/">关于“那些事儿”系列</a>
                </div>
                
                
            
            
                <div class="curtag-post-item ">
                    <a href="https://aituyaa.com/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/">函数柯里化</a>
                </div>
                
                
            
            
                <div class="curtag-post-item ">
                    <a href="https://aituyaa.com/%E5%97%A8pc/">嗨，PC</a>
                </div>
                
                
            
            
                <div class="curtag-post-item ">
                    <a href="https://aituyaa.com/%E5%9B%BE%E5%BA%8A%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/">图床那些事儿</a>
                </div>
                
                
            
            
                <div class="curtag-post-item curtag-post-item--active">
                    <a href="https://aituyaa.com/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a>
                </div>
                
                
            
            
                <div class="curtag-post-item ">
                    <a href="https://aituyaa.com/%E6%8B%A5%E6%8A%B1%E6%B8%85%E7%88%BD%E8%BF%9C%E7%A6%BB%E6%B9%BF%E6%B0%94/">拥抱清爽，远离湿气</a>
                </div>
                
                
            
            
                <div class="curtag-post-item ">
                    <a href="https://aituyaa.com/%E6%96%87%E5%AD%A6%E4%BD%93%E8%A3%81/">文学体裁</a>
                </div>
                
                
            
            
                <div class="curtag-post-item ">
                    <a href="https://aituyaa.com/%E6%B8%B8%E6%88%8F/">游戏</a>
                </div>
                
                
            
            
                <div class="curtag-post-item ">
                    <a href="https://aituyaa.com/%E7%94%A8%E6%B2%99%E5%AD%90%E9%80%A0%E7%9A%84-cpu-%E5%87%AD%E4%BB%80%E4%B9%88%E5%8D%96%E7%9A%84%E9%82%A3%E4%B9%88%E8%B4%B5/">用沙子造的 CPU 凭什么卖的那么贵</a>
                </div>
                
                
            
            
                <div class="curtag-post-item ">
                    <a href="https://aituyaa.com/%E7%BB%88%E7%AB%AF-terminal-%E5%AD%97%E7%AC%A6%E7%9A%84%E5%A4%9A%E5%BD%A9%E8%BE%93%E5%87%BA/">终端 Terminal 字符的多彩输出</a>
                </div>
                
                
            
            
                <div class="curtag-post-item ">
                    <a href="https://aituyaa.com/%E7%BC%96%E7%A8%8B%E6%B0%B4%E5%B9%B3%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%AD%E7%BB%83%E5%87%BA%E6%9D%A5%E7%9A%84/">编程水平是怎么训练出来的</a>
                </div>
                
                
            
            
                <div class="curtag-post-item ">
                    <a href="https://aituyaa.com/%E8%89%BE%E5%AE%BE%E6%B5%A9%E6%96%AF%E8%AE%B0%E5%BF%86%E9%81%97%E5%BF%98%E6%9B%B2%E7%BA%BF/">艾宾浩斯记忆遗忘曲线</a>
                </div>
                
                
            
            
                <div class="curtag-post-item ">
                    <a href="https://aituyaa.com/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/">费曼学习法</a>
                </div>
                
                
        </div>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    </div>
    
    

    <div class="desc">
        
        <span>
            
            <svg t="1656736000388" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"
                p-id="7409" width="12" height="12">
                <path
                    d="M524.885333 338.986667L200.362667 663.466667c-17.28 15.274667-27.989333 36.693333-29.696 56.234666v133.76l130.730666 0.085334c22.784-1.621333 43.989333-12.245333 61.013334-31.701334l322.688-322.645333-160.213334-160.213333z m60.373334-60.330667l160.170666 160.213333 102.144-102.144a19.712 19.712 0 0 0 0-27.861333L715.093333 176.426667a19.456 19.456 0 0 0-27.605333 0L585.258667 278.613333zM701.312 85.333333c27.946667 0 54.741333 11.136 74.282667 30.848l132.309333 132.309334a105.045333 105.045333 0 0 1 0 148.565333L424.874667 879.957333c-29.824 34.346667-72.106667 55.466667-120.448 58.794667H85.333333v-42.666667l0.128-179.84c3.626667-44.970667 24.576-86.826667 56.448-114.944l485.12-485.034666A104.789333 104.789333 0 0 1 701.269333 85.333333z"
                    p-id="7410" fill="#adb5bd"></path>
            </svg>
            2023-06-08&nbsp;&nbsp;&nbsp;
            <svg t="1656737270708" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"
                p-id="23838" width="11" height="11">
                <path
                    d="M824.264 95.36c0-23.859 25.043-44.16 48.902-44.16s49.714 20.301 49.714 44.16v190.08c0 23.859-19.054 52.868-42.913 52.868h-190.08c-23.859 0-46.696-25.96-46.696-49.819s22.55-46.249 46.409-46.249h82.025C702.344 175.534 610.22 155.853 512 155.853c-206.775 0-360.398 149.372-360.398 356.147 0 206.775 153.623 358.23 360.398 358.23 206.775 0 357.467-151.455 357.467-358.23 0-23.859 23.634-50.706 53.413-50.706 29.78 0 49.92 26.847 49.92 50.706 0 254.493-206.307 460.8-460.8 460.8-254.493 0-460.8-206.307-460.8-460.8C51.2 257.507 257.507 51.2 512 51.2c122.4 0 226.684 33.296 312.264 117.369 0.358 0.351 0.358-24.052 0-73.209z"
                    p-id="23839" fill="#adb5bd"></path>
            </svg>
            2023-09-07&nbsp;&nbsp;&nbsp;
        </span>
        <span>
            
            <svg t="1656737548689" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"
                p-id="33866" width="12" height="12">
                <path
                    d="M832.038608 64.662657H192.030028C121.255125 64.662657 63.940169 121.98845 63.940169 192.694717v446.793671C63.940169 710.205493 121.255125 767.643272 192.030028 767.643272h133.353183a63.940169 63.940169 0 0 1 55.219742 31.576328l76.099638 129.83828c12.358154 21.093031 33.790754 31.626903 55.216129 31.626903s42.832688-10.544709 55.198067-31.619678l76.222461-129.870792a63.940169 63.940169 0 0 1 55.212517-31.551041h133.54103c70.576219 0 127.732228-57.289669 127.732227-127.800865V192.391272C959.825022 121.85479 902.643727 64.662657 832.038608 64.662657zM895.884854 639.842407A63.85347 63.85347 0 0 1 832.092795 703.703103h-133.54103a127.753903 127.753903 0 0 0-110.349172 63.09847l-76.222461 129.856342a0.274545 0.274545 0 0 1 0-0.050574h-0.032512s-0.021675 0.061411-0.032512 0.061412l-76.1466-129.85273A127.804477 127.804477 0 0 0 325.383211 703.703103H192.030028A64.207489 64.207489 0 0 1 127.880338 639.488388V192.694717A64.102729 64.102729 0 0 1 192.030028 128.602826h640.00858A63.799284 63.799284 0 0 1 895.884854 192.391272v447.451135z"
                    fill="#adb5bd" p-id="33867"></path>
                <path
                    d="M608.154093 288.092004A31.970084 31.970084 0 0 0 576.184009 320.062089v160.078006l-134.650049-179.278119A31.970084 31.970084 0 0 0 384.002258 320.062089v255.760676a31.970084 31.970084 0 0 0 63.940169 0v-159.958796l134.650048 179.274507a31.970084 31.970084 0 0 0 57.531703-19.200113V320.062089a31.970084 31.970084 0 0 0-31.970085-31.970085z"
                    fill="#adb5bd" p-id="33868"></path>
            </svg>
            12901 字</span>&nbsp;
        <span>
            
            <svg t="1656737462334" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"
                p-id="32892" width="12" height="12">
                <path
                    d="M512 74.666667C270.933333 74.666667 74.666667 270.933333 74.666667 512S270.933333 949.333333 512 949.333333 949.333333 753.066667 949.333333 512 753.066667 74.666667 512 74.666667z m0 810.666666c-204.8 0-373.333333-168.533333-373.333333-373.333333S307.2 138.666667 512 138.666667 885.333333 307.2 885.333333 512 716.8 885.333333 512 885.333333z"
                    p-id="32893" fill="#adb5bd"></path>
                <path
                    d="M695.466667 567.466667l-151.466667-70.4V277.333333c0-17.066667-14.933333-32-32-32s-32 14.933333-32 32v238.933334c0 12.8 6.4 23.466667 19.2 29.866666l170.666667 81.066667c4.266667 2.133333 8.533333 2.133333 12.8 2.133333 12.8 0 23.466667-6.4 29.866666-19.2 6.4-14.933333 0-34.133333-17.066666-42.666666z"
                    p-id="32894" fill="#adb5bd"></path>
            </svg>
            26 分钟</span>
        <div class="container-ctgtag">
	<div class="taxonomy">
		<div class="tag">
			
			
			<a href="/tags/_misc">_Misc</a>
			
		</div>
	</div>
</div>
        
    </div>

    <div class="toc">
        <div class="container-page-operation">
	<div class="page-operation">
		<div><a href="/"><img src="/imgs/icons/home-2.svg" alt=""></a></div>
		<div><a href="/nav"><img src="/imgs/icons/iov-navigate-1.svg" alt=""></a></div>
		<div><a href="/wiki"><img src="/imgs/icons/wiki.svg" alt=""></a></div>
		<div><a href="/tags"><img src="/imgs/icons/treetags.svg" alt=""></a></div>
		<div id="light-dark"><a><img src="/imgs/icons/moon2.svg" alt=""></a></div>
		<div><a href="#"><img src="/imgs/icons/up2.svg" alt=""></a></div>
	</div>
</div>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#相关参考">相关参考</a></li>
    <li><a href="#简介">简介</a></li>
    <li><a href="#目录结构">目录结构</a></li>
    <li><a href="#配置小程序">配置小程序</a></li>
    <li><a href="#小程序框架">小程序框架</a>
      <ul>
        <li><a href="#逻辑层">逻辑层</a></li>
        <li><a href="#视图层">视图层</a></li>
        <li><a href="#事件系统">事件系统</a></li>
        <li><a href="#简易双向绑定">简易双向绑定</a></li>
        <li><a href="#基础组件">基础组件</a></li>
        <li><a href="#获取界面上的节点信息">获取界面上的节点信息</a></li>
      </ul>
    </li>
    <li><a href="#小程序运行时">小程序运行时</a>
      <ul>
        <li><a href="#运行机制">运行机制</a></li>
        <li><a href="#更新机制">更新机制</a></li>
      </ul>
    </li>
    <li><a href="#自定义组件">自定义组件</a>
      <ul>
        <li><a href="#组件模板和样式">组件模板和样式</a></li>
        <li><a href="#component-构造器">Component 构造器</a></li>
        <li><a href="#组件间通信与事件">组件间通信与事件</a></li>
        <li><a href="#组件生命周期">组件生命周期</a></li>
        <li><a href="#behaviors">behaviors</a></li>
        <li><a href="#组件间关系">组件间关系</a></li>
        <li><a href="#数据监听器">数据监听器</a></li>
        <li><a href="#纯数据字段">纯数据字段</a></li>
        <li><a href="#抽象节点">抽象节点</a></li>
        <li><a href="#自定义组件扩展">自定义组件扩展</a></li>
        <li><a href="#开发第三方自定义组件">开发第三方自定义组件</a></li>
        <li><a href="#占位组件">占位组件</a></li>
        <li><a href="#查看自定义组件数据">查看自定义组件数据</a></li>
      </ul>
    </li>
    <li><a href="#基础能力">基础能力</a>
      <ul>
        <li><a href="#网络">网络</a></li>
        <li><a href="#存储">存储</a></li>
        <li><a href="#文件系统">文件系统</a></li>
        <li><a href="#canvas">Canvas</a></li>
        <li><a href="#分包加载">分包加载</a></li>
        <li><a href="#按需注入和用时注入">按需注入和用时注入</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>

    <div class='content  '>
        <p>微信小程序开发的一些记录……</p>
<h2 id="相关参考">相关参考</h2>
<table>
<thead>
<tr>
<th>框架文档</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>微信官方文档</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">微信开放文档</a></td>
<td></td>
</tr>
<tr>
<td>TDesign</td>
<td><a href="https://tdesign.tencent.com/miniprogram/getting-started">TDesign</a></td>
<td>![[assets/Pasted image 20230608144221.png|102]]</td>
</tr>
<tr>
<td>Vant</td>
<td><a href="https://vant-contrib.gitee.io/vant-weapp/#/home">介绍 - Vant Weapp</a></td>
<td>![[assets/Pasted image 20230608144251.png|134]]</td>
</tr>
<tr>
<td>Taro</td>
<td><a href="https://taro-docs.jd.com/docs/">Taro 文档</a>、 <a href="https://taro-docs.jd.com/docs/">Taro 文档</a></td>
<td>![[assets/Pasted image 20230608144347.png|95]]</td>
</tr>
<tr>
<td>Uniapp</td>
<td><a href="https://uniapp.dcloud.net.cn/">uni-app官网</a></td>
<td>![[assets/Pasted image 20230608144441.png|148]]</td>
</tr>
</tbody>
</table>
<p>后两种都是可以生成多平台的框架，并且让你可以使用 Vue 或 React 来编写。</p>
<h2 id="简介">简介</h2>
<blockquote>
<p>这里只是一些并不系统的摘录，你总可以在 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">微信开放文档</a> 里获取更多详细的信息。</p>
</blockquote>
<p><strong>小程序的技术发展史</strong></p>
<p>JS API （如 WeixinJSBridage） &gt; JS-SDK &gt; 微信 Web 资源离线存储 (提升移动网页体验) &gt; 小程序</p>
<blockquote>
<p>:: todo 扩展了解 WebView 相关的知识</p>
</blockquote>
<p><strong>小程序与普通网页开发的区别</strong></p>
<p>网页开发渲染线程和脚本线程是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应，而在小程序中，二者是分开的，分别运行在不同的线程中。</p>
<p>网页开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作。小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的 DOM API 和 BOM API。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。</p>
<table>
<thead>
<tr>
<th><strong>运行环境</strong></th>
<th><strong>逻辑层</strong></th>
<th><strong>渲染层</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>iOS</td>
<td>JavaScriptCore</td>
<td>WKWebView</td>
</tr>
<tr>
<td>安卓</td>
<td>V8</td>
<td>chromium 定制内核</td>
</tr>
<tr>
<td>小程序开发者工具</td>
<td>NWJS</td>
<td>Chrome WebView</td>
</tr>
</tbody>
</table>
<p><code>&gt; 小程序的运行环境</code></p>
<p><strong>小程序代码构成</strong></p>
<p>小程序主要有以下四种格式的文件组成：</p>
<ol>
<li><code>.json</code> 后缀的 <code>JSON</code> 配置文件</li>
<li><code>.wxml</code> 后缀的 <code>WXML</code> 模板文件</li>
<li><code>.wxss</code> 后缀的 <code>WXSS</code> 样式文件</li>
<li><code>.js</code> 后缀的 <code>JS</code> 脚本逻辑文件</li>
</ol>
<p><strong>小程序的宿主环境</strong></p>
<p>我们称微信客户端给小程序所提供的环境为宿主环境。</p>
<p>小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。它们分别由 2 个线程管理：渲染层的界面使用了 WebView 进行渲染；逻辑层采用 JsCore 线程运行 JS 脚本。</p>
<p>一个小程序存在多个界面，所以渲染层存在多个 WebView 线程，这两个线程的通信会经由微信客户端（下文中也会采用 Native 来代指微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发，小程序的通信模型下图所示。</p>
<p>![[assets/Pasted image 20230609100400.png]]</p>
<p>微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。</p>
<p>紧接着通过 <code>app.json</code> 的 <code>pages</code> 字段就可以知道你当前小程序的所有页面路径，继而微信客户端会把首页的代码装载进来，通过小程序底层的一些机制，就可以渲染出这个首页。</p>
<p>小程序启动之后，在 <code>app.js</code> 定义的 <code>App</code> 实例的 <code>onLaunch</code> 回调会被执行。整个小程序只有一个 App 实例，是全部页面共享的。</p>
<p>那么，<strong>页面是如何装载、渲染的呢？</strong></p>
<p>微信客户端会先根据 <code>page.json</code> 配置生成一个界面，顶部的颜色和文字你都可以在这个 <code>json</code> 文件里边定义好。紧接着客户端就会装载这个页面的 <code>WXML</code> 结构和 <code>WXSS</code> 样式，最后客户端会装载 <code>page.js</code> （一个 <code>Page</code> 页面构造器）。</p>
<p><code>Page</code> 是一个页面构造器，这个构造器就生成了一个页面。在生成页面的时候，小程序框架会把 <code>data</code> 数据和 <code>index.wxml</code> 一起渲染出最终的结构，于是就得到了你看到的小程序的样子。</p>
<p>在渲染完界面之后，页面实例就会收到一个 <code>onLoad</code> 的回调，你可以在这个回调处理你的逻辑。</p>
<p><strong>组件 &amp; API</strong></p>
<p>小程序提供了丰富的基础组件给开发者，使用组件的时候，还可以通过属性传递值给组件，让组件可以以不同的状态去展现，组件的内部行为也会通过事件的形式让开发者可以感知。</p>
<p>为了让开发者可以很方便的调起微信提供的能力，例如获取用户信息、微信支付等等，小程序提供了很多 API 给开发者去使用。需要注意的是：多数 API 的回调都是异步，你需要处理好代码逻辑的异步问题。</p>
<h2 id="目录结构">目录结构</h2>
<p>小程序包含一个描述整体程序的 <code>app</code> 和多个描述各自页面的 <code>page</code>。</p>
<p>一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>必需</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html">app.js</a></td>
<td>是</td>
<td>小程序逻辑</td>
</tr>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/config.html">app.json</a></td>
<td>是</td>
<td>小程序公共配置</td>
</tr>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html">app.wxss</a></td>
<td>否</td>
<td>小程序公共样式表</td>
</tr>
</tbody>
</table>
<p>一个小程序页面由四个文件组成，分别是：</p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>必需</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html">js</a></td>
<td>是</td>
<td>页面逻辑</td>
</tr>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/">wxml</a></td>
<td>是</td>
<td>页面结构</td>
</tr>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE">json</a></td>
<td>否</td>
<td>页面配置</td>
</tr>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html">wxss</a></td>
<td>否</td>
<td>页面样式表</td>
</tr>
</tbody>
</table>
<p>注意：为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。</p>
<h2 id="配置小程序">配置小程序</h2>
<p><strong>全局配置</strong></p>
<p>小程序根目录下的 <code>app.json</code> 文件用来对微信小程序进行全局配置，<strong>决定页面文件的路径</strong>、窗口表现、设置网络超时时间、<strong>设置多 tab</strong> 等。</p>
<p><strong>页面配置</strong></p>
<p>每一个小程序页面也可以使用同名 <code>.json</code> 文件来对本页面的窗口表现进行配置，页面中配置项会覆盖 <code>app.json</code> 的 <code>window</code> 中相同的配置项。</p>
<p><strong>sitemap 配置</strong></p>
<p>微信现已开放小程序内搜索，开发者可以通过 <code>sitemap.json</code> 配置，或者管理后台页面收录开关来配置其小程序页面是否允许微信索引。当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索词条触发该索引时，小程序的页面将可能展示在搜索结果中。</p>
<p>……</p>
<h2 id="小程序框架">小程序框架</h2>
<p>小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。</p>
<p>整个小程序框架系统分为两部分： 逻辑层（App Service）和视图层（View）。</p>
<p>小程序提供了自己的视图层描述语言 <code>WXML</code> 和 <code>WXSS</code>，以及基于 <code>JavaScript</code> 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。</p>
<blockquote>
<p>:: 所有的 MVVM 系统基本上都是这个原理。</p>
</blockquote>
<p>框架的核心是一个响应的<strong>数据绑定</strong>系统，可以让数据与视图非常简单地保持同步。</p>
<p>框架管理了整个小程序的<strong>页面路由</strong>，可以做到页面间的无缝切换，并给以页面完整的生命周期。开发者需要做的只是将页面的数据、方法、生命周期函数注册到框架中，其他的一切复杂的操作都交由框架处理。</p>
<p>框架提供了一套<strong>基础组件</strong>，这些组件自带微信风格的样式以及特殊的逻辑，开发者可以通过组合基础组件，创建出强大的微信小程序。还提供丰富的<strong>微信原生 API</strong>，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。</p>
<h3 id="逻辑层">逻辑层</h3>
<p>小程序开发框架的逻辑层使用 <code>JavaScript</code> 引擎为小程序提供开发 <code>JavaScript</code> 代码的运行环境以及微信小程序的特有功能。</p>
<p>逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。</p>
<p>💡 开发者写的所有代码最终将会打包成一份 <code>JavaScript</code> 文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API">ServiceWorker</a>，所以逻辑层也称之为 App Service。</p>
<p>在 JavaScript 的基础上，我们增加了一些功能，以方便小程序的开发：</p>
<ul>
<li>增加 <code>App</code> 和 <code>Page</code> 方法，进行程序注册和页面注册。</li>
<li>增加 <code>getApp</code> 和 <code>getCurrentPages</code> 方法，分别用来获取 <code>App</code> 实例和当前页面栈。</li>
<li>提供丰富的 API，如微信用户数据，扫一扫，支付等微信特有能力。</li>
<li>提供模块化能力，每个页面有独立的作用域。</li>
</ul>
<p>注意：小程序框架的逻辑层并非运行在浏览器中，因此 JavaScript 在 web 中一些能力都无法使用，如 <code>window</code>，<code>document</code> 等。</p>
<p><strong>如何注册页面呢？</strong></p>
<ul>
<li>使用 <code>Page</code> 构造器注册页面</li>
<li>使用 <code>Component</code> 构造器构造页面</li>
</ul>
<p><code>Page</code> 构造器适用于简单的页面。但对于复杂的页面， <code>Page</code> 构造器可能并不好用。此时，可以使用 <code>Component</code> 构造器来构造页面。 <code>Component</code> 构造器的主要区别是：方法需要放在 <code>methods: { }</code> 里面。</p>
<p><strong>在页面中使用 behaviors</strong></p>
<p>页面可以引用 behaviors ， behaviors 可以用来让多个页面有相同的数据字段和方法。</p>
<blockquote>
<p>:: 类似 mixin 机制</p>
</blockquote>
<p><strong>页面 Page 实例的生命周期</strong></p>
<p>![[assets/Pasted image 20230609111716.png|550]]</p>
<p><strong>页面路由</strong></p>
<p>在小程序中所有页面的路由全部由框架进行管理，框架以<strong>页面栈</strong>的形式维护了当前的所有页面，开发者可以使用 <code>getCurrentPages()</code> 函数获取当前页面栈。</p>
<blockquote>
<p>:: 对于路由的触发方式以及页面生命周期函数，有一些小技巧可以注意一下，即：</p>
<ul>
<li>所有的页面出现在前台时都会触发 <code>onShow</code></li>
<li>只有新页面入栈时（页面创建），路由后页面才会触发 <code>onLoad</code></li>
<li>页面出栈, 路由前页面就会触发 <code>onUnload</code></li>
<li>只有打开新页面时，路由前页面才会触发 <code>onHide</code></li>
</ul>
</blockquote>
<p>注意事项：</p>
<ul>
<li><code>navigateTo</code>, <code>redirectTo</code> 只能打开非 tabBar 页面。</li>
<li><code>switchTab</code> 只能打开 tabBar 页面。</li>
<li><code>reLaunch</code> 可以打开任意页面。</li>
<li>页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。</li>
<li>调用页面路由带的参数可以在目标页面的 <code>onLoad</code> 中获取。</li>
</ul>
<p><strong>模块化？</strong></p>
<p>可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/module.html"><code>module.exports</code></a> 或者 <code>exports</code> 才能对外暴露接口。</p>
<p>​在需要使用这些模块的文件中，使用 <code>require</code> 将公共代码引入。</p>
<blockquote>
<p>:: 对，就是 CommonJS 那一套。</p>
</blockquote>
<p><strong>API ?</strong></p>
<ul>
<li>事件监听 API</li>
<li>同步 API</li>
<li>异步 API</li>
</ul>
<p><strong>事件监听 API</strong>。我们约定，以 <code>on</code> 开头的 API 用来监听某个事件是否触发。这类 API 接受一个回调函数作为参数，当事件触发时会调用这个回调函数，并将相关数据以参数形式传入。</p>
<p><strong>同步 API</strong> 。我们约定，以 <code>Sync</code> 结尾的 API 都是同步 API。</p>
<p><strong>异步 API</strong> 。大多数 API 都是异步 API，这类 API 接口通常都接受一个 <code>Object</code> 类型的参数，这个参数都支持按需指定以下字段来接收接口调用结果。异步 API 的执行结果需要通过 <code>Object</code> 类型的参数中传入的对应回调函数获取。部分异步 API 也会有返回值，可以用来实现更丰富的功能。</p>
<p><strong>异步 API 可以返回 Promise 吗?</strong></p>
<p>基础库 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.10.2</a> 版本起，异步 API 支持 callback &amp; promise 两种调用方式。当接口参数 Object 对象中不包含 <code>success/fail/complete</code> 时将默认返回 promise，否则仍按回调方式执行，无返回值。</p>
<p>注意：部分接口如 <code>downloadFile</code>, <code>request</code>, <code>uploadFile</code>, <code>connectSocket</code>, <code>createCamera</code>（小游戏）本身就有返回值，它们的 promisify 需要开发者自行封装。</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#998;font-style:italic">// callback 形式调用
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>wx.chooseImage({
</span></span><span style="display:flex;"><span>  success(res) {
</span></span><span style="display:flex;"><span>    console.log(<span style="color:#d14">&#39;res:&#39;</span>, res)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// promise 形式调用
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>wx.chooseImage().then(res =&gt; console.log(<span style="color:#d14">&#39;res: &#39;</span>, res))
</span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">// 也可使用 async &amp; await
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>小程序支持去开发 API 了 ？</strong></p>
<p>是的（收费 💸），开通并使用<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html">微信云开发</a>，即可使用云开发 API，在小程序端直接调用服务端的<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/functions.html#%E4%BA%91%E5%87%BD%E6%95%B0">云函数</a>。</p>
<h3 id="视图层">视图层</h3>
<p>框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示，如：</p>
<ul>
<li>WXML (WeiXin Markup language) 用于描述页面的结构。</li>
<li>WXS (WeiXin Script) 是小程序的一套脚本语言，结合 <code>WXML</code>，可以构建出页面的结构。</li>
<li>WXSS (WeiXin Style Sheet) 用于描述页面的样式。</li>
</ul>
<p>将逻辑层的数据反映成视图，同时将视图层的事件发送给逻辑层。</p>
<p>💡 组件 (Component)是视图的基本组成单元。</p>
<blockquote>
<p>:: 微信小程序提供的这套框架，最终还是要打包成一个 js 文件，这和 Vue、React 及像 Webpack、 Rollup 这类打包工具是一样的。这也是，为什么现在有许多不使用微信小程序框架开发，可以使用相应的 Vue、 React 语法来开发的原因了，如 Taro ， Uniapp 等。</p>
</blockquote>
<p><strong>WXML 是什么？</strong></p>
<p>WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。</p>
<p>具体的能力以及使用方式在以下章节查看：</p>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/data.html">数据绑定</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/list.html">列表渲染</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/conditional.html">条件渲染</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/template.html">模板</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/import.html">引用</a></p>
<p><strong>WXSS 是什么？</strong></p>
<p>WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。</p>
<p>为了适应广大的前端开发者，WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。</p>
<p>与 CSS 相比，WXSS 扩展的特性有：</p>
<ul>
<li>尺寸单位</li>
<li>样式导入</li>
</ul>
<p><strong>尺寸单位 rpx（responsive pixel）</strong> ，可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。如在 iPhone6 上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx = 375px = 750 物理像素，1rpx = 0.5px = 1 物理像素。</p>
<p><strong>样式导入</strong>，使用 <code>@import</code> 语句可以导入外联样式表，<code>@import</code> 后跟需要导入的外联样式表的相对路径，用 <code>;</code> 表示语句结束。</p>
<p>框架组件上支持使用 <code>style</code> （动态样式）、 <code>class</code> （静态样式） 属性来控制组件的样式。</p>
<p><strong>WXS ？ ？ ？</strong></p>
<p>WXS（WeiXin Script）是小程序的一套脚本语言，结合 <code>WXML</code>，可以构建出页面的结构。</p>
<p>WXS 与 JavaScript 是不同的语言，有自己的语法，并不和 JavaScript 一致。WXS 的运行环境和其他 JavaScript 代码是隔离的，WXS 中<strong>不能</strong>调用其他 JavaScript 文件中定义的函数，<strong>也不能</strong>调用小程序提供的 API。</p>
<pre tabindex="0"><code class="language-wxml" data-lang="wxml">&lt;!--wxml--&gt;
&lt;wxs module=&#34;m1&#34;&gt;
var msg = &#34;hello world&#34;;

module.exports.message = msg;
&lt;/wxs&gt;

&lt;view&gt; {{m1.message}} &lt;/view&gt;
</code></pre><blockquote>
<p>:: 怎么说呢？是不是很像 <code>&lt;script&gt;</code> ? 又有点类似于 <code>computed</code> 。</p>
</blockquote>
<h3 id="事件系统">事件系统</h3>
<p><strong>什么是事件？</strong></p>
<ul>
<li>事件是视图层到逻辑层的通讯方式；</li>
<li>事件可以将用户的行为反馈到逻辑层进行处理；</li>
<li><strong>事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数；</strong></li>
<li>事件对象可以携带额外信息，如 id, dataset, touches。</li>
</ul>
<p>也可以使用 WXS 函数响应事件，但不常用。</p>
<p>事件分为冒泡事件和非冒泡事件：</p>
<ol>
<li>冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。</li>
<li>非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。</li>
</ol>
<p><strong>有哪些冒泡事件呢？</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>触发条件</th>
<th>最低版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>touchstart</td>
<td>手指触摸动作开始</td>
<td></td>
</tr>
<tr>
<td>touchmove</td>
<td>手指触摸后移动</td>
<td></td>
</tr>
<tr>
<td>touchcancel</td>
<td>手指触摸动作被打断，如来电提醒，弹窗</td>
<td></td>
</tr>
<tr>
<td>touchend</td>
<td>手指触摸动作结束</td>
<td></td>
</tr>
<tr>
<td>tap</td>
<td>手指触摸后马上离开</td>
<td></td>
</tr>
<tr>
<td>longpress</td>
<td>手指触摸后，超过 350ms 再离开，如果指定了事件回调函数并触发了这个事件，tap 事件将不被触发</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.5.0</a></td>
</tr>
<tr>
<td>longtap</td>
<td>手指触摸后，超过 350ms 再离开（推荐使用 longpress 事件代替）</td>
<td></td>
</tr>
<tr>
<td>transitionend</td>
<td>会在 WXSS transition 或 wx. createAnimation 动画结束后触发</td>
<td></td>
</tr>
<tr>
<td>animationstart</td>
<td>会在一个 WXSS animation 动画开始时触发</td>
<td></td>
</tr>
<tr>
<td>animationiteration</td>
<td>会在一个 WXSS animation 一次迭代结束时触发</td>
<td></td>
</tr>
<tr>
<td>animationend</td>
<td>会在一个 WXSS animation 动画完成时触发</td>
<td></td>
</tr>
<tr>
<td>touchforcechange</td>
<td>在支持 3D Touch 的 iPhone 设备，重按时会触发</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.9.90</a></td>
</tr>
</tbody>
</table>
<p>注：除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如 form 的 <code>submit</code> 事件，input 的 <code>input</code> 事件，scroll-view 的 <code>scroll</code> 事件。(详见各个组件)</p>
<p><strong>如何进行事件绑定呢？</strong></p>
<p>事件绑定的写法类似于组件的属性，如：</p>
<pre tabindex="0"><code class="language-wxml" data-lang="wxml">&lt;!-- 点击 view ，页面的 handleTap 会被调用 --&gt;
&lt;view bindtap=&#34;handleTap&#34;&gt;
    Click here!
&lt;/view&gt;
</code></pre><p>事件绑定函数可以是一个数据绑定（并不推荐），如：</p>
<pre tabindex="0"><code class="language-wxml" data-lang="wxml">&lt;view bindtap=&#34;{{ handlerName }}&#34;&gt;
    Click here!
&lt;/view&gt;
</code></pre><p>此时，页面的 <code>this.data.handlerName</code> 必须是一个字符串，指定事件处理函数名；如果它是个空字符串，则这个绑定会失效（可以利用这个特性来暂时禁用一些事件）。</p>
<p>自基础库版本 1.5.0 起，在大多数组件和自定义组件中， <code>bind</code> 后可以紧跟一个冒号，其含义不变，如 <code>bind: tap</code> 。基础库版本 2.8.1 起，在所有组件中开始提供这个支持。</p>
<blockquote>
<p>:: 这更新有什么用？一开始就应该用冒号！</p>
</blockquote>
<p><strong>绑定并阻止事件冒泡</strong></p>
<p>除 <code>bind</code> 外，也可以用 <code>catch</code> 来绑定事件。与 <code>bind</code> 不同， <code>catch</code> 会阻止事件向上冒泡。</p>
<p>自基础库版本 2.8.2 起，除 <code>bind</code> 和 <code>catch</code> 外，还可以使用 <code>mut-bind</code> 来绑定事件。一个 <code>mut-bind</code> 触发后，如果事件冒泡到其他节点上，其他节点上的 <code>mut-bind</code> 绑定函数不会被触发，但 <code>bind</code> 绑定函数和 <code>catch</code> 绑定函数依旧会被触发。</p>
<p><strong>事件的捕获阶段？</strong></p>
<p>捕获阶段位于冒泡阶段之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反。需要在捕获阶段监听事件时，可以采用 <code>capture-bind</code>、<code>capture-catch</code> 关键字，后者将中断捕获阶段和取消冒泡阶段。</p>
<p>如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。这个<strong>事件对象</strong>是什么样的呢？</p>
<p><strong>⭐ 事件对象</strong></p>
<p>BaseEvent 基础事件对象属性列表：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
<th>基础库版本</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#type">type</a></td>
<td>String</td>
<td>事件类型</td>
<td></td>
</tr>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#timeStamp">timeStamp</a></td>
<td>Integer</td>
<td>事件生成时的时间戳</td>
<td></td>
</tr>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#target">target</a></td>
<td>Object</td>
<td>触发事件的组件的一些属性值集合</td>
<td></td>
</tr>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#currenttarget">currentTarget</a></td>
<td>Object</td>
<td>当前组件的一些属性值集合</td>
<td></td>
</tr>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#mark">mark</a></td>
<td>Object</td>
<td>事件标记数据</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.7.1</a></td>
</tr>
</tbody>
</table>
<p>CustomEvent 自定义事件对象属性列表（继承 BaseEvent）：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#detail">detail</a></td>
<td>Object</td>
<td>额外的信息</td>
</tr>
</tbody>
</table>
<blockquote>
<p>自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息，详见<a href="https://developers.weixin.qq.com/miniprogram/dev/component">组件</a>定义中各个事件的定义。</p>
<p>点击事件的 <code>detail</code> 带有的 x, y 同 pageX, pageY 代表距离文档左上角的距离。</p>
</blockquote>
<p>TouchEvent 触摸事件对象属性列表（继承 BaseEvent）：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#touches">touches</a></td>
<td>Array</td>
<td>触摸事件，当前停留在屏幕中的触摸点信息的数组</td>
</tr>
<tr>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#changedTouches">changedTouches</a></td>
<td>Array</td>
<td>触摸事件，当前变化的触摸点信息的数组</td>
</tr>
</tbody>
</table>
<p>特殊事件： <a href="https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html">canvas</a> 中的触摸事件不可冒泡，所以没有 currentTarget。</p>
<p>这里也有 <code>target</code> 和 <code>currentTarget</code> ，它们有什么不同呢？</p>
<pre tabindex="0"><code class="language-wxml" data-lang="wxml">&lt;view id=&#34;outer&#34; bindtap=&#34;handleTap1&#34;&gt;
  outer view
  &lt;view id=&#34;middle&#34; catchtap=&#34;handleTap2&#34;&gt;
    middle view
    &lt;view id=&#34;inner&#34; bindtap=&#34;handleTap3&#34;&gt;
      inner view
    &lt;/view&gt;
  &lt;/view&gt;
&lt;/view&gt;
</code></pre><p>说明： target 和 currentTarget 可以参考上例中，点击 inner view 时，<code>handleTap3</code> 收到的事件对象 target 和 currentTarget 都是 inner，而 <code>handleTap2</code> 收到的事件对象 target 就是 inner，currentTarget 就是 middle。</p>
<p>原来， <strong><code>target</code> 指的是触发事件的源组件；而 <code>currentTarget</code> 是指事件绑定的当前组件。</strong></p>
<table>
<thead>
<tr>
<th>组件</th>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>target</td>
<td>id</td>
<td>String</td>
<td>事件源组件的 id</td>
</tr>
<tr>
<td></td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#dataset">dataset</a></td>
<td>Object</td>
<td>事件源组件上由 <code>data-</code> 开头的自定义属性组成的集合</td>
</tr>
<tr>
<td>&mdash;</td>
<td>&mdash;</td>
<td>&mdash;</td>
<td>&mdash;</td>
</tr>
<tr>
<td>currentTarget</td>
<td>id</td>
<td>String</td>
<td>当前组件的 id</td>
</tr>
<tr>
<td></td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#dataset">dataset</a></td>
<td>Object</td>
<td>当前组件上由 <code>data-</code> 开头的自定义属性组成的集合</td>
</tr>
</tbody>
</table>
<p>在组件节点中可以附加一些自定义数据。这样，在事件中可以获取这些自定义的节点数据，用于事件的逻辑处理。</p>
<p>在 WXML 中，这些自定义数据以 <code>data-</code> 开头，多个单词由连字符 <code>-</code> 连接。这种写法中，连字符写法会转换成驼峰写法，而大写字符会自动转成小写字符。</p>
<blockquote>
<p>:: 基本上和 html 的一样的。</p>
</blockquote>
<p><strong>mark 又是个啥？</strong></p>
<p>在基础库版本 2.7.1 以上，可以使用 <code>mark</code> 来识别具体触发事件的 target 节点。此外， <code>mark</code> 还可以用于承载一些自定义数据（类似于 <code>dataset</code> ）。</p>
<p>当事件触发时，事件冒泡路径上所有的 <code>mark</code> 会被合并，并返回给事件回调函数。（即使事件不是冒泡事件，也会 <code>mark</code> 。）</p>
<pre tabindex="0"><code class="language-wxml" data-lang="wxml">&lt;view mark:myMark=&#34;last&#34; bindtap=&#34;bindViewTap&#34;&gt;
  &lt;button mark:anotherMark=&#34;leaf&#34; bindtap=&#34;bindButtonTap&#34;&gt;按钮&lt;/button&gt;
&lt;/view&gt;
</code></pre><p>在上述 WXML 中，如果按钮被点击，将触发 <code>bindViewTap</code> 和 <code>bindButtonTap</code> 两个事件，事件携带的 <code>event.mark</code> 将包含 <code>myMark</code> 和 <code>anotherMark</code> 两项。</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>Page({
</span></span><span style="display:flex;"><span>  bindViewTap<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">function</span>(e) {
</span></span><span style="display:flex;"><span>    e.mark.myMark <span style="color:#000;font-weight:bold">===</span> <span style="color:#d14">&#34;last&#34;</span> <span style="color:#998;font-style:italic">// true
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>    e.mark.anotherMark <span style="color:#000;font-weight:bold">===</span> <span style="color:#d14">&#34;leaf&#34;</span> <span style="color:#998;font-style:italic">// true
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  }
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>mark</code> 和 <code>dataset</code> 很相似，主要区别在于： <code>mark</code> 会包含从触发事件的节点到根节点上所有的 <code>mark:</code> 属性值；而 <code>dataset</code> 仅包含一个节点的 <code>data-</code> 属性值。</p>
<p><strong>touches &amp; changedTouches</strong></p>
<p>touches 是一个数组，每个元素为一个 Touch 对象（canvas 触摸事件中携带的 touches 是 CanvasTouch 数组），表示当前停留在屏幕上的触摸点。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>identifier</td>
<td>Number</td>
<td>触摸点的标识符</td>
</tr>
<tr>
<td>pageX, pageY</td>
<td>Number</td>
<td>距离文档左上角的距离，文档的左上角为原点，横向为 X 轴，纵向为 Y 轴</td>
</tr>
<tr>
<td>clientX, clientY</td>
<td>Number</td>
<td>距离页面可显示区域（屏幕除去导航条）左上角距离，横向为 X 轴，纵向为 Y 轴</td>
</tr>
</tbody>
</table>
<p><code>&gt; Touch 对象</code></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>说明</th>
<th>特殊说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>identifier</td>
<td>Number</td>
<td>触摸点的标识符</td>
<td></td>
</tr>
<tr>
<td>x, y</td>
<td>Number</td>
<td>距离 Canvas 左上角的距离，Canvas 的左上角为原点，横向为 X 轴，纵向为 Y 轴</td>
<td></td>
</tr>
</tbody>
</table>
<p><code>&gt; CanvasTouch 对象</code></p>
<p>changedTouches 数据格式同 touches ，表示有变化的触摸点，如从无变有（touchstart），位置变化（touchmove），从有变无（touchend、touchcancel）。</p>
<p><strong>为什么需要 WXS 响应事件？</strong></p>
<p>有频繁用户交互的效果在小程序上表现是比较卡顿的！</p>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/interactive-animation.html">WXS响应事件 | 微信开放文档</a></p>
<p>……</p>
<h3 id="简易双向绑定">简易双向绑定</h3>
<p>在 WXML 中，普通的属性的绑定是单向的。例如：</p>
<pre tabindex="0"><code class="language-wxml" data-lang="wxml">&lt;input value=&#34;{{value}}&#34; /&gt;
</code></pre><p>如果使用 <code>this.setData({ value: 'leaf' })</code> 来更新 <code>value</code> ，<code>this.data.value</code> 和输入框的中显示的值都会被更新为 <code>leaf</code> ；但如果用户修改了输入框里的值，却不会同时改变 <code>this.data.value</code> 。</p>
<p>如果需要在用户输入的同时改变 <code>this.data.value</code> 呢？借助简易双向绑定机制。</p>
<p>此时，可以在对应项目之前加入 <code>model:</code> 前缀：</p>
<pre tabindex="0"><code>&lt;input model:value=&#34;{{value}}&#34; /&gt;
</code></pre><p>这样，如果输入框的值被改变了， <code>this.data.value</code> 也会同时改变。同时， WXML 中所有绑定了 <code>value</code> 的位置也会被一同更新， <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html">数据监听器</a> 也会被正常触发。</p>
<p>如果想<strong>在自定义组件中传递双向绑定</strong>呢？一样的。</p>
<h3 id="基础组件">基础组件</h3>
<p><strong>什么是组件？</strong></p>
<ul>
<li>组件是视图层的基本组成单元。</li>
<li>组件自带一些功能与微信风格一致的样式。</li>
<li>一个组件通常包括 <code>开始标签</code> 和 <code>结束标签</code>，<code>属性</code> 用来修饰这个组件，<code>内容</code> 在两个标签之内。</li>
</ul>
<p>注意：所有组件与属性都是小写，以连字符 <code>-</code> 连接。</p>
<p>所有组件都有以下属性：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>类型</th>
<th>描述</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>String</td>
<td>组件的唯一标示</td>
<td>保持整个页面唯一</td>
</tr>
<tr>
<td>class</td>
<td>String</td>
<td>组件的样式类</td>
<td>在对应的 WXSS 中定义的样式类</td>
</tr>
<tr>
<td>style</td>
<td>String</td>
<td>组件的内联样式</td>
<td>可以动态设置的内联样式</td>
</tr>
<tr>
<td>hidden</td>
<td>Boolean</td>
<td>组件是否显示</td>
<td>所有组件默认显示</td>
</tr>
<tr>
<td>data-*</td>
<td>Any</td>
<td>自定义属性</td>
<td>组件上触发的事件时，会发送给事件处理函数</td>
</tr>
<tr>
<td>bind*  catch*</td>
<td>EventHandler</td>
<td>组件的事件</td>
<td>详见<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html">事件</a></td>
</tr>
</tbody>
</table>
<p>几乎所有组件都有各自定义的属性，可以对该组件的功能或样式进行修饰，请参考各个<a href="https://developers.weixin.qq.com/miniprogram/dev/component/">组件</a>的定义。</p>
<h3 id="获取界面上的节点信息">获取界面上的节点信息</h3>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/selector.html">获取界面上的节点信息 | 微信开放文档</a></p>
<p>……</p>
<p>后续还有一些章节，这里先不做讨论。</p>
<h2 id="小程序运行时">小程序运行时</h2>
<p>微信小程序运行在多种平台上：iOS/iPadOS 微信客户端、Android 微信客户端、Windows PC 微信客户端、Mac 微信客户端、<a href="https://developers.weixin.qq.com/doc/oplatform/Miniprogram_Frame/">小程序硬件框架</a>和用于调试的微信开发者工具等。</p>
<p>不同运行环境下，脚本执行环境以及用于组件渲染的环境是不同的，性能表现也存在差异。</p>
<h3 id="运行机制">运行机制</h3>
<p><strong>小程序的生命周期</strong></p>
<p>小程序从启动到最终被销毁，会经历很多不同的状态，小程序在不同状态下会有不同的表现。</p>
<p>![[assets/Pasted image 20230609160107.png]]</p>
<p><strong>1. 小程序的启动</strong></p>
<p>从用户认知的角度看，广义的小程序启动可以分为两种情况，一种是<strong>冷启动</strong>，一种是<strong>热启动</strong>。</p>
<ul>
<li>冷启动：如果用户首次打开，或小程序销毁后被用户再次打开，此时小程序需要重新加载启动，即冷启动。</li>
<li>热启动：如果用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态，这个过程就是热启动。</li>
</ul>
<p>从小程序生命周期的角度来看，我们一般讲的「<strong>启动</strong>」专指冷启动，热启动一般被称为后台切前台。</p>
<p><strong>2. 前台与后台</strong></p>
<p>小程序启动后，界面被展示给用户，此时小程序处于「<strong>前台</strong>」状态。</p>
<p>当用户「关闭」小程序时，小程序并没有真正被关闭，而是进入了「<strong>后台</strong>」状态，此时小程序还可以短暂运行一小段时间，但部分 API 的使用会受到限制。</p>
<p><strong>3. 挂起</strong></p>
<p>小程序进入「后台」状态一段时间后（目前是 5 秒），微信会停止小程序 JS 线程的执行，小程序进入「<strong>挂起</strong>」状态。此时小程序的内存状态会被保留，但开发者代码执行会停止，事件和接口回调会在小程序再次进入「前台」时触发。</p>
<p>当开发者使用了<a href="https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.getBackgroundAudioManager.html">后台音乐播放</a>、<a href="https://developers.weixin.qq.com/miniprogram/dev/api/location/wx.startLocationUpdateBackground.html">后台地理位置</a>等能力时，小程序可以在「后台」持续运行，不会进入到「挂起」状态。</p>
<p><strong>4. 小程序销毁</strong></p>
<p>如果用户很久没有使用小程序，或者系统资源紧张，小程序会被「<strong>销毁</strong>」，即完全终止运行。</p>
<p><strong>5. 退出状态</strong></p>
<p>小程序冷启动时，如果启动时不带 path（A 类场景），默认情况下将会进入小程序的首页。在页面对应的 json 文件中（也可以全局配置在 app. json 的 window 段中），指定 <code>restartStrategy</code> 配置项可以改变这个默认的行为，使得从某个页面退出后，下次 A 类场景的冷启动可以回到这个页面。</p>
<table>
<thead>
<tr>
<th>可选值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>homePage</td>
<td>（默认值）如果从这个页面退出小程序，下次将从首页冷启动</td>
</tr>
<tr>
<td>homePageAndLatestPage</td>
<td>如果从这个页面退出小程序，下次冷启动后立刻加载这个页面，页面的参数保持不变（不可用于 tab 页）</td>
</tr>
</tbody>
</table>
<p><code>&gt; restartStrategy 可选值</code></p>
<p>无论如何，页面中的状态并不会被保留，如输入框中的文本内容、 checkbox 的勾选状态等都不会还原。如果需要还原或部分还原，需要利用<strong>退出状态</strong>。</p>
<p>每当小程序可能被销毁之前，页面回调函数 <code>onSaveExitState</code> 会被调用。如果想保留页面中的状态，可以在这个回调函数中“保存”一些数据，下次启动时可以通过 <code>exitState</code> 获得这些已保存数据。</p>
<p><code>onSaveExitState</code> 返回值可以包含两项：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>data</td>
<td>Any</td>
<td>需要保存的数据（只能是 JSON 兼容的数据）</td>
</tr>
<tr>
<td>expireTimeStamp</td>
<td>Number</td>
<td>超时时刻，在这个时刻后，保存的数据保证一定被丢弃，默认为 (当前时刻 + 1 天)</td>
</tr>
</tbody>
</table>
<h3 id="更新机制">更新机制</h3>
<p>开发者在管理后台发布新版本的小程序之后，微信客户端会有若干个时机去检查本地缓存的小程序有没有新版本，并进行小程序的代码包更新。但如果用户本地有小程序的历史版本，此时打开的可能还是旧版本。</p>
<p>……</p>
<p>注意： 开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内覆盖绝大多数用户。</p>
<h2 id="自定义组件">自定义组件</h2>
<p>开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似。</p>
<p><strong>如何创建一个自定义组件呢？</strong></p>
<p>类似于页面，一个自定义组件由 <code>json</code> <code>wxml</code> <code>wxss</code> <code>js</code> 4 个文件组成。要编写一个自定义组件，首先需要在 <code>json</code> 文件中进行自定义组件声明（将 <code>component</code> 字段设为 <code>true</code> 可将这一组文件设为自定义组件）：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#000080">&#34;component&#34;</span>: <span style="color:#000;font-weight:bold">true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>同时，还要在 <code>wxml</code> 文件中编写组件模板，在 <code>wxss</code> 文件中加入组件样式，它们的写法与页面的写法类似。</p>
<p>注意：在组件 wxss 中不应使用 ID 选择器、属性选择器和标签名选择器。</p>
<p>在自定义组件的 <code>js</code> 文件中，需要使用 <code>Component()</code> 来注册组件，并提供组件的属性定义、内部数据和自定义方法。</p>
<p>组件的属性值和内部数据将被用于组件 <code>wxml</code> 的渲染，其中，属性值是可由组件外部传入的。</p>
<p><strong>如何创使用自定义组件呢？</strong></p>
<p>使用已注册的自定义组件前，首先要在页面的 <code>json</code> 文件中进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径：</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#000080">&#34;usingComponents&#34;</span>: {
</span></span><span style="display:flex;"><span>    <span style="color:#000080">&#34;component-tag-name&#34;</span>: <span style="color:#d14">&#34;path/to/the/custom/component&#34;</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样，在页面的 <code>wxml</code> 中就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。</p>
<h3 id="组件模板和样式">组件模板和样式</h3>
<p>组件模板的写法与页面模板相同。组件模板与组件数据结合后生成的节点树，将被插入到组件的引用位置上。</p>
<p>与普通的 WXML 模板类似，可以使用数据绑定，这样就可以向子组件的属性传递动态数据。</p>
<p>在组件模板中可以提供一个 <code>&lt;slot&gt;</code> 节点，用于承载组件引用时提供的子节点。默认情况下，一个组件的 wxml 中只能有一个 slot 。需要使用多 slot 时，可以在组件 js 中声明启用。</p>
<div class="highlight"><div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span>Component({
</span></span><span style="display:flex;"><span>  options<span style="color:#000;font-weight:bold">:</span> {
</span></span><span style="display:flex;"><span>    multipleSlots<span style="color:#000;font-weight:bold">:</span> <span style="color:#000;font-weight:bold">true</span> <span style="color:#998;font-style:italic">// 在组件定义时的选项中启用多slot支持
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>  },
</span></span><span style="display:flex;"><span>  properties<span style="color:#000;font-weight:bold">:</span> { <span style="color:#998;font-style:italic">/* ... */</span> },
</span></span><span style="display:flex;"><span>  methods<span style="color:#000;font-weight:bold">:</span> { <span style="color:#998;font-style:italic">/* ... */</span> }
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时，可以在这个组件的 wxml 中使用多个 slot ，以不同的 <code>name</code> 来区分。</p>
<p>关于组件样式的及样式隔离相关方面的知识，我们先不讨论。</p>
<h3 id="component-构造器">Component 构造器</h3>
<p><code>Component</code> 构造器可用于定义组件，调用 <code>Component</code> 构造器时可以指定组件的属性、数据、方法等。</p>
<p>事实上，小程序的页面也可以视为自定义组件。因而，页面也可以使用 <code>Component</code> 构造器构造，拥有与普通组件一样的定义段与实例方法。但此时要求对应 json 文件中包含 <code>usingComponents</code> 定义段。</p>
<p>此时，组件的属性可以用于接收页面的参数，如访问页面 <code>/pages/index/index?paramA=123&amp;paramB=xyz</code> ，如果声明有属性 <code>paramA</code> 或 <code>paramB</code> ，则它们会被赋值为 <code>123</code> 或 <code>xyz</code> 。</p>
<p>页面的生命周期方法（即 <code>on</code> 开头的方法），应写在 <code>methods</code> 定义段中。</p>
<p>💡 使用 <code>Component</code> 构造器来构造页面的一个好处是可以使用 <code>behaviors</code> 来提取所有页面中公用的代码段。</p>
<h3 id="组件间通信与事件">组件间通信与事件</h3>
<p>组件间的基本通信方式有以下几种：</p>
<ul>
<li>WXML 数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容数据；</li>
<li>事件：用于子组件向父组件传递数据，可以传递任意数据；</li>
<li>如果以上两种方式不足以满足需要，父组件还可以通过 <code>this.selectComponent</code> 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。</li>
</ul>
<p><strong>监听事件</strong></p>
<p>事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。</p>
<p>监听自定义组件事件的方法与监听基础组件事件的方法完全一致。</p>
<p><strong>触发事件</strong></p>
<p>自定义组件触发事件时，需要使用 <code>triggerEvent</code> 方法，指定事件名、detail 对象和事件选项。</p>
<p><strong>获取组件实例</strong></p>
<p>可在父组件里调用 <code>this.selectComponent</code> ，获取子组件的实例对象。</p>
<p>若需要自定义 <code>selectComponent</code> 返回的数据，可使用内置 <code>behavior</code>: <code>wx://component-export</code> 。</p>
<h3 id="组件生命周期">组件生命周期</h3>
<p>组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。</p>
<p>其中，最重要的生命周期是 <code>created</code> <code>attached</code> <code>detached</code> ，包含一个组件实例生命流程的最主要时间点。</p>
<ul>
<li>组件实例刚刚被创建好时， <code>created</code> 生命周期被触发。此时，组件数据 <code>this.data</code> 就是在 <code>Component</code> 构造器中定义的数据 <code>data</code> 。 <strong>此时还不能调用 <code>setData</code> 。</strong> 通常情况下，这个生命周期只应该用于给组件 <code>this</code> 添加一些自定义属性字段。</li>
<li>在组件完全初始化完毕、进入页面节点树后， <code>attached</code> 生命周期被触发。此时， <code>this.data</code> 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。</li>
<li>在组件离开页面节点树后， <code>detached</code> 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 <code>detached</code> 会被触发。</li>
</ul>
<p>在 behaviors 中也可以编写生命周期方法，同时不会与其他 behaviors 中的同名生命周期相互覆盖。但要注意，如果一个组件多次直接或间接引用同一个 behavior ，这个 behavior 中的生命周期函数在一个执行时机内只会执行一次。</p>
<p>可用的全部生命周期如下表所示：</p>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>参数</th>
<th>描述</th>
<th>最低版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>created</td>
<td>无</td>
<td>在组件实例刚刚被创建时执行</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.6.3</a></td>
</tr>
<tr>
<td>attached</td>
<td>无</td>
<td>在组件实例进入页面节点树时执行</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.6.3</a></td>
</tr>
<tr>
<td>ready</td>
<td>无</td>
<td>在组件在视图层布局完成后执行</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.6.3</a></td>
</tr>
<tr>
<td>moved</td>
<td>无</td>
<td>在组件实例被移动到节点树另一个位置时执行</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.6.3</a></td>
</tr>
<tr>
<td>detached</td>
<td>无</td>
<td>在组件实例被从页面节点树移除时执行</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">1.6.3</a></td>
</tr>
<tr>
<td>error</td>
<td><code>Object Error</code></td>
<td>每当组件方法抛出错误时执行</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.4.1</a></td>
</tr>
</tbody>
</table>
<p>还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为“<strong>组件所在页面的生命周期</strong>”，在 <code>pageLifetimes</code> 定义段中定义。</p>
<table>
<thead>
<tr>
<th>生命周期</th>
<th>参数</th>
<th>描述</th>
<th>最低版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>show</td>
<td>无</td>
<td>组件所在的页面被展示时执行</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.2.3</a></td>
</tr>
<tr>
<td>hide</td>
<td>无</td>
<td>组件所在的页面被隐藏时执行</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.2.3</a></td>
</tr>
<tr>
<td>resize</td>
<td><code>Object Size</code></td>
<td>组件所在的页面尺寸变化时执行</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.4.0</a></td>
</tr>
<tr>
<td>routeDone</td>
<td>无</td>
<td>组件所在页面路由动画完成时执行</td>
<td><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html">2.31.2</a></td>
</tr>
</tbody>
</table>
<p>注意：自定义 tabBar 的 pageLifetime 不会触发。</p>
<h3 id="behaviors">behaviors</h3>
<p><code>behaviors</code> 是用于组件间代码共享的特性，类似于一些编程语言中的 “mixins” 或 “traits”。</p>
<p>每个 <code>behavior</code> 可以包含一组属性、数据、生命周期函数和方法。<strong>组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。</strong> 每个组件可以引用多个 <code>behavior</code> ，<code>behavior</code> 也可以引用其它 <code>behavior</code> 。</p>
<p>自定义组件可以通过引用内置的 <code>behavior</code> 来获得内置组件的一些行为。</p>
<h3 id="组件间关系">组件间关系</h3>
<p>……</p>
<h3 id="数据监听器">数据监听器</h3>
<p>数据监听器（<code>observers</code>）可以用于监听和响应任何属性和数据字段的变化。</p>
<h3 id="纯数据字段">纯数据字段</h3>
<p>纯数据字段是一些不用于界面渲染的 data 字段，可以用于提升页面更新性能。</p>
<p>有些情况下，某些 <code>data</code> 中的字段（包括 <code>setData</code> 设置的字段）既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。</p>
<p>此时，可以指定这样的数据字段为“纯数据字段”，它们将仅仅被记录在 <code>this.data</code> 中，而不参与任何界面渲染过程，这样有助于提升页面更新性能。</p>
<p>指定“纯数据字段”的方法是在 <code>Component</code> 构造器的 <code>options</code> 定义段中指定 <code>pureDataPattern</code> 为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段。</p>
<h3 id="抽象节点">抽象节点</h3>
<p>有时，自定义组件模板中的一些节点，其对应的自定义组件不是由自定义组件本身确定的，而是自定义组件的调用者确定的。这时可以把这个节点声明为“抽象节点”。</p>
<p>例如，我们现在来实现一个“选框组”（selectable-group）组件，它其中可以放置单选框（custom-radio）或者复选框（custom-checkbox）。</p>
<h3 id="自定义组件扩展">自定义组件扩展</h3>
<p>为了更好定制自定义组件的功能，可以使用自定义组件扩展机制。</p>
<p>所谓‘自定义组件的扩展’其实就是提供了修改自定义组件定义段的能力。<code>Behavior()</code> 构造器提供了新的定义段 <code>definitionFilter</code> ，用于支持自定义组件扩展。</p>
<h3 id="开发第三方自定义组件">开发第三方自定义组件</h3>
<p>……</p>
<h3 id="占位组件">占位组件</h3>
<p>基础库尝试渲染一个组件时，会首先递归检查 <code>usingComponents</code>，收集其将使用到的所有组件的信息；在这个过程中，如果某个被使用到的组件不可用，基础库会先检查其是否有对应的占位组件。如果没有，基础库会中断渲染并抛出错误；如果有，则会标记并在后续渲染流程中使用占位组件替换该不可用的组件进行渲染。不可用的组件会在当前渲染流程结束后尝试准备（下载分包或注入代码等）；等到准备过程完成后，再尝试渲染该组件（实际上也是在执行这个流程），并替换掉之前渲染的占位组件。</p>
<h3 id="查看自定义组件数据">查看自定义组件数据</h3>
<p>wxml 面板中可以查看自定义组件在渲染时的 Data 数据。在 wxml 中先选中需要查看的自定义组件，然后切换到 <code>Component Data</code> 即可实时查看当前自定义组件的数据。</p>
<h2 id="基础能力">基础能力</h2>
<h3 id="网络">网络</h3>
<p>在小程序/小游戏中使用网络相关的 API 时，需要注意下列问题，请开发者提前了解。</p>
<h3 id="存储">存储</h3>
<p>同一个微信用户，同一个小程序 storage 上限为 10MB。</p>
<h3 id="文件系统">文件系统</h3>
<p>文件系统是小程序提供的一套以小程序和用户维度隔离的存储以及一套相应的管理接口。通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/file/wx.getFileSystemManager.html">wx.getFileSystemManager()</a> 可以获取到全局唯一的文件系统管理器，所有文件系统的管理操作通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/file/FileSystemManager.html">FileSystemManager</a> 来调用。</p>
<p>文件主要分为两大类：</p>
<ul>
<li>代码包文件：代码包文件指的是在项目目录中添加的文件。</li>
<li>本地文件：通过调用接口本地产生，或通过网络下载下来，存储到本地的文件。</li>
</ul>
<p>其中本地文件又分为三种：</p>
<ol>
<li>本地临时文件：临时产生，随时会被回收的文件。运行时最多存储 4GB，结束运行后，如果已使用超过 2GB，会以文件为维度按照最近使用时间从远到近进行清理至少于 2GB。</li>
<li>本地缓存文件：小程序通过接口把本地临时文件缓存后产生的文件，不能自定义目录和文件名。跟本地用户文件共计，小程序（含小游戏）最多可存储 200MB。</li>
<li>本地用户文件：小程序通过接口把本地临时文件缓存后产生的文件，允许自定义目录和文件名。跟本地缓存文件共计，小程序（含小游戏）最多可存储 200MB。</li>
</ol>
<p><strong>代码包文件</strong></p>
<p>代码包文件的访问方式是从项目根目录开始写文件路径，不支持相对路径的写法。如：<code>/a/b/c</code>、<code>a/b/c</code> 都是合法的，<code>./a/b/c</code> <code>../a/b/c</code> 则不合法。</p>
<p><strong>本地文件</strong></p>
<p>本地文件指的是小程序被用户添加到手机后，会有一块独立的文件存储区域，以用户维度隔离。即同一台手机，每个微信用户不能访问到其他登录用户的文件，同一个用户不同 appId 之间的文件也不能互相访问。</p>
<h3 id="canvas">Canvas</h3>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html">canvas 组件</a> 提供了绘制界面，可以在之上进行任意绘制。</p>
<h3 id="分包加载">分包加载</h3>
<p>某些情况下，开发者需要将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。</p>
<p>在构建小程序分包项目时，构建会输出一个或多个分包。每个使用分包小程序必定含有一个<strong>主包</strong>。所谓的主包，即放置默认启动页面/TabBar 页面，以及一些所有分包都需用到公共资源/JS 脚本；而<strong>分包</strong>则是根据开发者的配置进行划分。</p>
<p>在小程序启动时，默认会下载主包并启动主包内页面，当用户进入分包内某个页面时，客户端会把对应分包下载下来，下载完成后再进行展示。</p>
<p>前小程序分包大小有以下限制：</p>
<ul>
<li>整个小程序所有分包大小不超过 20M</li>
<li>单个分包/主包大小不能超过 2M</li>
</ul>
<p><strong>使用分包</strong></p>
<p>开发者通过在 app. json <code>subpackages</code> 字段声明项目分包结构。</p>
<blockquote>
<p>:: 这个对于稍微大点的项目，是很必要的。</p>
</blockquote>
<p><strong>独立分包</strong></p>
<p>独立分包是小程序中一种特殊类型的分包，可以独立于主包和其他分包运行。从独立分包中页面进入小程序时，不需要下载主包。当用户进入普通分包或主包内页面时，主包才会被下载。</p>
<p>一个小程序中可以有多个独立分包。</p>
<p>开发者通过在 <code>app.json</code> 的 <code>subpackages</code> 字段中对应的分包配置项中定义 <code>independent</code> 字段声明对应分包为独立分包。</p>
<p><strong>分包预下载</strong></p>
<p>开发者可以通过配置，在进入小程序某个页面时，由框架自动预下载可能需要的分包，提升进入后续分包页面时的启动速度。对于<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/independent.html">独立分包</a>，也可以预下载主包。</p>
<p>分包预下载目前只支持通过配置方式使用，暂不支持通过调用 API 完成。</p>
<p>预下载分包行为在进入某个页面时触发，通过在 <code>app.json</code> 增加 <code>preloadRule</code> 配置来控制。</p>
<p><strong>分包异步化</strong></p>
<p><strong>跨分包自定义组件引用</strong> ，一个分包使用其他分包的自定义组件时，由于其他分包还未下载或注入，其他分包的组件处于不可用的状态。通过为其他分包的自定义组件设置 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/placeholder.html">占位组件</a>，我们可以先渲染占位组件作为替代，在分包下载完成后再进行替换。</p>
<p><strong>跨分包 JS 代码引用</strong>，一个分包中的代码引用其它分包的代码时，为了不让下载阻塞代码运行，我们需要异步获取引用的结果。</p>
<h3 id="按需注入和用时注入">按需注入和用时注入</h3>
<p>……</p>
    </div>

    

    <div class="container-comment-giscus">
        <script src="https://giscus.app/client.js"
        data-repo="loveminimal/comment"
        data-repo-id="R_kgDOJNJQ8g"
        data-category="General"
        data-category-id="DIC_kwDOJNJQ8s4CYl0m"
        data-mapping="title"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="noborder_light"
        data-lang="zh-CN"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
        </script>
</div>
</div>

        </div>
        <div id="footer"><div class="container-footer">
    

    <div class="beian">
        
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=">
            

        </a>

        
        <a href="/about" target="_blank">
            
            将喜欢的一切留在身边，这便是努力的意义
            
        </a>
    </div>

    
    <div class="info">
        
        <a href="https://github.com/loveminimal/hugo-theme-virgo">🕊️</a> 2016 - <span id="info-date"></span>
    </div>

</div></div>
        <div class="cool-after" style="
            
                background-color: rgba(255, 255, 255, 0.69); 
                backdrop-filter: saturate(180%) blur(6px);
            
            "></div>
    </body>
</html>
